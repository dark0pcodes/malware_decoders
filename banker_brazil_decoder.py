"""
Authos: Felipe Duarte

Decrypting Brazilian Banker Strings

For this to work, you need to manually extract from memory the unpacked version of the banker and its key.
"""

import subprocess

HEX_REGEX = r'[0-9A-Fa-f]{8,}'
IP_REGEX = r'^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$'


def crypt_decrypt(data, xor_key):
    plain_txt = bytearray([])

    for i in range(2, len(data), 2):
        tmp_str = (int(data[i:i + 2], 16) ^ ord((xor_key[(int(i/2) % len(xor_key)) - 1]))) - int(data[i-2:i], 16)
        plain_txt.append(tmp_str + 0xFF if tmp_str < 0 else tmp_str)
    return plain_txt.decode()


if __name__ == '__main__':
    print('Brazilian Bankers String Decryptor by @dark0pcodes\n')

    # Construct the argument parser
    ap = argparse.ArgumentParser()

    # Add the arguments to the parser
    ap.add_argument('-k', '--key', required=True, help='Mekotio decryption Key')
    ap.add_argument('-p', '--payload', required=True, help='Mekotio unpacked payload')

    args = ap.parse_args()
    cmd = subprocess.run(['strings', '-e', 'l', args.payload], stdout=subprocess.PIPE, text=True)

    print('[+] Starting Decryption Process...')
    ip_addresses = []

    for string in cmd.stdout.split('\n'):
        if re.match(HEX_REGEX, string):
            try:
                print(f'\t[-] {string}\t->\t{crypt_decrypt(string, args.key)}')
            except (UnicodeDecodeError, ValueError):
                continue
        elif re.match(IP_REGEX, string) and string not in ['0.0.0.0', '127.0.0.1', '255.255.255.255', '0.0.0.1']:
            ip_addresses.append(string)

    print('[+] IP Addresses Found:')

    for ip in ip_addresses:
        print(f'\t[-] {ip}')
